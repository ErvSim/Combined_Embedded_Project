#include "OLED.h"
#include "pico/stdlib.h"
#include "hardware/i2c.h"

// Function prototypes
int oled_send_command(uint8_t cmd);
int oled_send_data(const uint8_t *data, size_t len);
void oled_init(void);
void prepare_for_data(void);
void print_char(char c);
void print_string(const char *str, uint8_t start_row);

// global variable
static const uint8_t clear_screen[1024] = {0};

static const uint8_t font_8x8[96][8] =
    {
        // ASCII 32 (space)
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        // ASCII 33 (!) to 64 (@) – 32 entries:
        {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00}, // !
        {0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00}, // "
        {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00}, // #
        {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00}, // $
        {0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00}, // %
        {0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00}, // &
        {0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
        {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // (
        {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00}, // )
        {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00}, // *
        {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00}, // +
        {0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // ,
        {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00}, // -
        {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // .
        {0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00}, // /
                                                          // ASCII 48 ('0')
        {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00}, // 0
        {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // 1
        {0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00}, // 2
        {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00}, // 3
        {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00}, // 4
        {0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00}, // 5
        {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00}, // 6
        {0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, 0x00}, // 7
        {0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // 8
        {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00}, // 9
                                                          //  ASCII 58 (:) to 64 (@) – 7 entries:
        {0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // :
        {0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // ;
        {0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // <
        {0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00}, // =
        {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00}, // >
        {0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00}, // ?
        {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00}, // @
                                                          // ASCII 65 (A) to 90 (Z) – 26 entries:
        {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00}, // A
        {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // B
        {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00}, // C
        {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00}, // D
        {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00}, // E
        {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00}, // F
        {0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00}, // G
        {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00}, // H
        {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00}, // I
        {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00}, // J
        {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00}, // K
        {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // L
        {0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00, 0x00, 0x00}, // M
        {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00}, // N
        {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00}, // O
        {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00}, // P
        {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00}, // Q
        {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00}, // R
        {0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00}, // S
        {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00}, // T
        {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00}, // U
        {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00}, // V
        {0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00, 0x00}, // W
        {0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00}, // X
        {0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00}, // Y
        {0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00}, // Z
                                                          // ASCII 91 ([), 92 (\), 93 (]), 94 (^), 95 (_)
        {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00}, // [
        {0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00}, // '\'
        {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00}, // ]
        {0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00}, // ^
        {0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // _
                                                          // ASCII 96 (`)
        {0x00, 0x03, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00}, // `
                                                          // ASCII 97 (a) to 122 (z) – 26 entries:
        {0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00}, // a
        {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // b
        {0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00}, // c
        {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00}, // d
        {0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00}, // e
        {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00}, // f
        {0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x00, 0x00}, //'g'
        {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // h
        {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00}, // i
        {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00}, // j
        {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00}, // k
        {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // l
        {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, 0x00}, // m
        {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // n
        {0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // o
        {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00}, // p
        {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00, 0x00, 0x00}, // q
        {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00}, // r
        {0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00}, // s
        {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00}, // t
        {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00}, // u
        {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00}, // v
        {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00, 0x00}, // w
        {0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00}, // x
        {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00}, // y
        {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00}, // z
                                                          // ASCII 123 ({), 124 (|), 125 (}), 126 (~), 127 (DEL)
        {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00}, // {
        {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00}, // |
        {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00}, // }
        {0x08, 0x04, 0x08, 0x10, 0x08, 0x00, 0x00, 0x00}, // ~
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}  // DEL
};

// Send command to OLED
int oled_send_command(uint8_t cmd)
{
    uint8_t buffer[2] = {0x00, cmd};
    return i2c_write_timeout_us(i2c0, 0x3C, buffer, 2, false, 30000);
}

// Send data to OLED
int oled_send_data(const uint8_t *data, size_t len)
{
    uint8_t buffer[len + 1];
    buffer[0] = 0x40;
    for (int i = 0; i < len; i++)
    {
        buffer[i + 1] = data[i];
    }
    return i2c_write_timeout_us(i2c0, 0x3C, buffer, len + 1, false, 30000);
}

// Initialize OLED with necessary commands (from github)
void oled_init(void)
{
    oled_send_command(0xAE); // Display off
    oled_send_command(0x20); // Set Memory Addressing Mode
    oled_send_command(0x00); // Horizontal addressing mode
    oled_send_command(0x40); // Set display start line to 0
    oled_send_command(0xA1); // Segment remap
    oled_send_command(0xA8); // Multiplex ratio
    oled_send_command(0x3F); // 64MUX
    oled_send_command(0xC8); // COM scan direction
    oled_send_command(0xD3); // Set display offset
    oled_send_command(0x00);
    oled_send_command(0xDA); // COM pin hardware configuration
    oled_send_command(0x12);
    oled_send_command(0xD5); // Display clock divide ratio/oscillator frequency
    oled_send_command(0x80);
    oled_send_command(0xD9); // Pre-charge period
    oled_send_command(0xF1);
    oled_send_command(0xDB); // VCOMH deselect level
    oled_send_command(0x30);
    oled_send_command(0x81); // Contrast control
    oled_send_command(0xFF);
    oled_send_command(0xA4); // Resume display from RAM
    oled_send_command(0xA6); // Normal display
    oled_send_command(0x8D); // Charge pump setting
    oled_send_command(0x14);
    oled_send_command(0xAF); // Turn on OLED display
    sleep_ms(10);
}

// Prepare OLED for data transfer (from github)
void prepare_for_data(void)
{
    oled_send_command(0x21); // Set column address
    oled_send_command(0x00);
    oled_send_command(0x7F);
    oled_send_command(0x22); // Set page address
    oled_send_command(0x00);
    oled_send_command(0x07);
    sleep_ms(100);

    oled_send_data(clear_screen, 1024);
}

// Print a single character on OLED
void print_char(char c)
{
    if (c < 32 || c > 127)
        return;
    const uint8_t *bitmap = font_8x8[c - 32];
    oled_send_data((uint8_t *)bitmap, 8);
}

// Print a string to the OLED with automatic row wrapping
void print_string(const char *str, uint8_t start_row)
{
    uint8_t current_row = start_row;
    uint8_t char_count = 0;
    uint8_t max_chars_per_row = 16; // 128 pixels wide, 8 pixels per character
    uint8_t word_len = 0;

    while (*str)
    {
        // Check for spaces to calculate word length
        const char *word_start = str;
        while (*str != ' ' && *str != '\0')
        {
            word_len++;
            str++;
        }

        // Check if the word fits in the remaining space
        if (char_count + word_len > max_chars_per_row)
        {
            // Move to the next row if the word doesn't fit
            char_count = 0;
            current_row++;

            // Handle row overflow (loop back to first row if out of bounds)
            if (current_row > 7)
            {
                current_row = 0;
            }

            // Set new row address
            oled_send_command(0x21); // Set Column Address
            oled_send_command(0x00); // Start at column 0
            oled_send_command(0x7F); // End at column 127
            oled_send_command(0x22); // Set Page Address
            oled_send_command(current_row);
            oled_send_command(0x07);
        }

        // Print the word
        while (word_len--)
        {
            print_char(*word_start++);
            char_count++;
        }

        // Print space if there's room after the word
        if (*str == ' ')
        {
            print_char(' ');
            char_count++;
            str++;
        }

        // Reset word length for the next word
        word_len = 0;
    }
}
